"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[6084],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},c=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),p=a,m=c["".concat(l,".").concat(p)]||c[p]||h[p]||i;return n?o.createElement(m,r(r({ref:t},u),{},{components:n})):o.createElement(m,r({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}c.displayName="MDXCreateElement"},77677:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var o=n(87462),a=(n(67294),n(3905));const i={sidebar_position:7},r="Superfluid Staking",s={unversionedId:"features/superfluid",id:"features/superfluid",title:"Superfluid Staking",description:"Abstract",source:"@site/docs/overview/features/superfluid.md",sourceDirName:"features",slug:"/features/superfluid",permalink:"/overview/features/superfluid",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/overview/features/superfluid.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"IBC Rate Limit",permalink:"/overview/features/ibc-rate-limit"},next:{title:"Token Factory",permalink:"/overview/features/tokenfactory"}},l={},d=[{value:"Abstract",id:"abstract",level:2},{value:"The process",id:"the-process",level:3},{value:"Example",id:"example",level:3},{value:"Why mint Osmo? How is this method safe and accurate?",id:"why-mint-osmo-how-is-this-method-safe-and-accurate",level:3},{value:"Bonding, unbonding, slashing",id:"bonding-unbonding-slashing",level:3},{value:"Bonding",id:"bonding",level:3},{value:"Unbonding",id:"unbonding",level:3},{value:"Concepts",id:"concepts",level:2},{value:"SyntheticLockups",id:"syntheticlockups",level:3},{value:"Intermediary Account",id:"intermediary-account",level:3},{value:"Intermediary Account Connection",id:"intermediary-account-connection",level:3},{value:"State",id:"state",level:2},{value:"Superfluid Asset",id:"superfluid-asset",level:3},{value:"Intermediary Accounts",id:"intermediary-accounts",level:3},{value:"Dedicated Gauges",id:"dedicated-gauges",level:3},{value:"Synthetic Lockups created",id:"synthetic-lockups-created",level:3},{value:"Osmo Equivalent Multipliers",id:"osmo-equivalent-multipliers",level:3}],u={toc:d};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"superfluid-staking"},"Superfluid Staking"),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,'Superfluid Staking provides the consensus layer more security with a\nsort of "Proof of Useful Stake". Each person gets an amount of Osmo\nrepresentative of the value of their share of liquidity pool tokens\nstaked and delegated to validators, resulting in the security guarantee\nof the consensus layer to also be based on GAMM LP shares. The OSMO\ntoken is minted and burned in the context of Superfluid Staking.\nThroughout all of this, OSMO\'s supply is preserved in queries to the\nbank module.'),(0,a.kt)("h3",{id:"the-process"},"The process"),(0,a.kt)("p",null,"All of the below methods are found under the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/tree/main/x/superfluid"},"Superfluid\nmodules"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"SuperfluidDelegate")," method stores your share of bonded\nliquidity pool tokens, with ",(0,a.kt)("inlineCode",{parentName:"li"},"validateLock")," as a verifier for lockup\ntime."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GetSuperfluidOsmo")," mints OSMO tokens each day for delegation as a\nrepresentative of the value of your pool share. This amount is\nminted because the staking module at the moment requires staked\ntokens to be in OSMO. This amount is burned each day and re-minted\nto keep the representative amount of the value of your pool share\naccurate. The lockup duration is guaranteed from the underlying\nlockup module."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"GetExpectedDelegationAmount")," iterates over each (denom, delegate)\npair and checks for how much OSMO we have delegated. The difference\nfrom the current balance to what is expected is burned / minted to\nmatch with the expected."),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"messageServer")," method executes the Superfluid delegate message."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"syntheticLockup")," is used to index bond holders and tracking their\naddresses for reward distribution or potentially slashing purposes.\nThese track whether if your Superfluid stake is currently bonding or\nunbonding."),(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("inlineCode",{parentName:"li"},"IntermediaryAccount")," is mostly used for the actual reward\ndistribution or slashing events, and are responsible for\nestablishing the connection between each superfluid staked lock and\ntheir delegation to the validator. These work by transferring the\nsuperfluid OSMO to their respective delegators. Rewards are linearly\nscaled based on how much you have locked for a given (validator,\ndenom) pair. Rewards are first moved to the incentive gauges, then\ndistributed from the gauges. In this way, we're using the existing\ngauge reward system for paying out superfluid staking rewards and\ntracking the amount you have superfluidly staked using the lockup\nmodule."),(0,a.kt)("li",{parentName:"ul"},"Rewards are distributed per epoch, which is currently a day.\n",(0,a.kt)("inlineCode",{parentName:"li"},"abci.go")," checks whether or not the current block is at the\nbeginning of the epoch using ",(0,a.kt)("inlineCode",{parentName:"li"},"BeginBlock"),"."),(0,a.kt)("li",{parentName:"ul"},"Superfluid staking will continue to expand to other Osmosis pools\nbased on governance proposals and vote turnouts.")),(0,a.kt)("h3",{id:"example"},"Example"),(0,a.kt)("p",null,"If Alice has 500 GAMM tokens bonded to the ATOM \\<",">"," OSMO, she will have\nthe equivalent value of OSMO minted, delegated to her chosen staker, and\nburned for her each day with Superfluid staking. On the user side, all\nshe has to know is who she wants to delegate her tokens to. In order to\nswitch delegation, she has to unbond her tokens from the pool first and\nthen redeposit. Bob, who has a share of the same liquidity pool before\nSuperfluid Staking went live, also has to re-deposit into the pool for\nthe above process to kickstart."),(0,a.kt)("h3",{id:"why-mint-osmo-how-is-this-method-safe-and-accurate"},"Why mint Osmo? How is this method safe and accurate?"),(0,a.kt)("p",null,"Superfluid staking requires the minting of OSMO because in order to\nstake on the Osmosis chain, OSMO tokens are required as the chosen\ncollateral. Synthetic Osmo is minted here as a representative of the\nvalue of each superfluid staker's liquidity pool tokens."),(0,a.kt)("p",null,"The pool tokens are acquired by the user from normally staking in a\nliquidity pool. They get minted an amount of OSMO equivalent to the\nvalue of their GAMM pool tokens. This method is accurate because\nquerying the value OSMO every day allows for burning and minting\naccording to the difference in value of OSMO relative to the expected\ndelegation amount (as seen with\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/blob/main/x/superfluid/keeper/stake.go"},"GetExpectedDelegationAmount"),").\nIt's like having a price oracle for fairly calculating the amount the\nuser has superfluidly staked."),(0,a.kt)("p",null,'On epoch (start of every day), we read from the lockup module how much\nGAMM tokens we have locked which acts as an oracle for the\nrepresentative price of the GAMM token shares. The superfluid module has\n"hooks" messages to refresh delegation amounts\n(',(0,a.kt)("inlineCode",{parentName:"p"},"RefreshIntermediaryDelegationAmounts"),") and to increase delegation on\nlockup (",(0,a.kt)("inlineCode",{parentName:"p"},"IncreaseSuperfluidDelegation"),"). Then, we see whether or not the\nsuperfluid OSMO currently delegated is worth more or less than this\nexpected delegation amount amount. If the OSMO is worth more, we do\ninstant undelegations and immediately burn the OSMO. If less, we mint\nOSMO and update the amount delegated. "),(0,a.kt)("p",null,"This minting is safe because we strict constrain the permissions of Bank\n(the module that burns and mints OSMO) to do what it's designed to do.\nThe authority is mediated through ",(0,a.kt)("inlineCode",{parentName:"p"},"mintOsmoTokensAndDelegate")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"forceUndelegateAndBurnOsmoTokens")," keeper methods called by the\n",(0,a.kt)("inlineCode",{parentName:"p"},"SuperfluidDelegate")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"SuperfluidUndelegate")," message handlers for the\ntokens. The hooks above that increase delegation and refresh delegation\namounts also call this keeper method."),(0,a.kt)("p",null,"The delegation is then verified to not already be associated with an\nintermediary account (to prevent double-staking), and is always\ndelegated or withdrawn taking into account various multipliers for\nsynthetic OSMO value (its worth with respect to the liquidity pool, and\na risk modifier) to prevent mint inaccuracies. Before minting, we also\ncheck that the message sender is the owner of the locked funds; that the\nlock is not unlocking; is locked for at least the unbonding period, and\nis bonded to a single asset. We also check to see if the lock isn't\nalready in superfluid and that the same lock isn't currently being\nunbonded."),(0,a.kt)("p",null,"On the end of each epoch, we iterate through all intermediary accounts\nto withdraw delegation rewards they may have received and put it all\ninto the perpetual gauges corresponding to each account for reward\ndelegation."),(0,a.kt)("h3",{id:"bonding-unbonding-slashing"},"Bonding, unbonding, slashing"),(0,a.kt)("p",null,"Here, we describe how token bonding and unbonding works, and what\nhappens to your superfluid tokens in the case of a slashing event."),(0,a.kt)("h3",{id:"bonding"},"Bonding"),(0,a.kt)("p",null,"When bonding, your input tokens are locked up and you are given GAMM\npool tokens in exchange. These GAMM pool tokens represent a share of the\ntotal liquidity pool, and allows you to get transaction fees or\nparticipate in external incentive gauge token distributions. When\nbonding, on top of the regular bonding transaction there will also be a\nselection of validators. As stated above, OSMO is also minted and burned\neach day and superfluidly staked to whoever you have chosen to be your\nvalidator. You gain additional APR as a reward for bolstering the\nOsmosis chain's consensus integrity by delegating."),(0,a.kt)("h3",{id:"unbonding"},"Unbonding"),(0,a.kt)("p",null,"When unbonding, superfluid tokens get un-delegated. After making sure\nthat the unbond message sender is the owner of their corresponding\nlocked funds, the existing synthetic lockup is deleted and replaced with\na new synthetic lockup for unbonding purposes. The undelegated OSMO is\nthen instantly withdrawn from the intermediate account and validator\nusing the InstantUndelegate function. The OSMO that was originally used\nfor representing your LP shares are burnt. Moves the tracker for\nunbonding, allows the underlying lock to start unlocking if desired"),(0,a.kt)("h2",{id:"concepts"},"Concepts"),(0,a.kt)("h3",{id:"syntheticlockups"},"SyntheticLockups"),(0,a.kt)("p",null,"SyntheticLockups are synthetica of PeriodLocks, but different in the\nsense that they store suffix, which is a combination of\nbonding/unbonding status + validator address. This is mainly used to\ntrack whether an individual lock that has been superfluid staked has an\nbonding status or a unbonding status from the staking delegations."),(0,a.kt)("h3",{id:"intermediary-account"},"Intermediary Account"),(0,a.kt)("p",null,"Intermediary Accounts establishes the connections between the superfluid\nstaked locks and delegations to the validator. Intermediary accounts\nexists for every denom + validator combination, so that it would group\nlocks with the same denom + validator selection. Superfluid staking a\nlock would mint equivalent amount of OSMO of the lock and send it to the\nintermediary account and the intermediarry accounts would be delegating\nto the specified validator."),(0,a.kt)("h3",{id:"intermediary-account-connection"},"Intermediary Account Connection"),(0,a.kt)("p",null,"Intermediary Accounts Connection serves the role of tracking the locks\nthat an Intermediary Account is dedicated to."),(0,a.kt)("h2",{id:"state"},"State"),(0,a.kt)("h3",{id:"superfluid-asset"},"Superfluid Asset"),(0,a.kt)("p",null,"A superfluid asset is a alternative asset (non-OSMO) that is allowed by\ngovernance to be used for staking."),(0,a.kt)("p",null,"It can only be updated by governance proposals. We validate at proposal\ncreation time that the denom + pool exists. (Are we going to ignore edge\ncases around a reference pool getting deleted it)"),(0,a.kt)("h3",{id:"intermediary-accounts"},"Intermediary Accounts"),(0,a.kt)("p",null,"Lots of questions to be answered here"),(0,a.kt)("h3",{id:"dedicated-gauges"},"Dedicated Gauges"),(0,a.kt)("p",null,"Each intermediary account has has dedicated gauge where it sends the\ndelegation rewards to. Gauges are distributing the rewards to end users\nat the end of the epoch."),(0,a.kt)("h3",{id:"synthetic-lockups-created"},"Synthetic Lockups created"),(0,a.kt)("p",null,"At the moment, one lock can only be fully bonded to one validator."),(0,a.kt)("h3",{id:"osmo-equivalent-multipliers"},"Osmo Equivalent Multipliers"),(0,a.kt)("p",null,"The Osmo Equivalent Multiplier for an asset is the multiplier it has for\nits value relative to OSMO."),(0,a.kt)("p",null,"Different types of assets can have different functions for calculating\ntheir multiplier. We currently support two asset types."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Native Token")),(0,a.kt)("p",null,"The multiplier for OSMO is always 1."),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Gamm LP Shares")),(0,a.kt)("p",null,"Currently we use the spot price for an asset based on a designated\nosmo-basepair pool of an asset. The multiplier is set once per epoch, at\nthe beginning of the epoch. In the future, we will switch this out to\nuse a TWAP instead."))}h.isMDXComponent=!0}}]);