"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[6513],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,p=u["".concat(c,".").concat(h)]||u[h]||m[h]||s;return n?a.createElement(p,r(r({ref:t},d),{},{components:n})):a.createElement(p,r({ref:t},d))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,r=new Array(s);r[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var l=2;l<s;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},74618:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var a=n(87462),o=(n(67294),n(3905));const s={sidebar_position:5},r="IBC Hooks",i={unversionedId:"features/ibc-hooks",id:"features/ibc-hooks",title:"IBC Hooks",description:"Wasm Hooks",source:"@site/docs/overview/features/ibc-hooks.md",sourceDirName:"features",slug:"/features/ibc-hooks",permalink:"/overview/features/ibc-hooks",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/overview/features/ibc-hooks.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Fee Abstraction",permalink:"/overview/features/fee-abstraction"},next:{title:"IBC Rate Limit",permalink:"/overview/features/ibc-rate-limit"}},c={},l=[{value:"Wasm Hooks",id:"wasm-hooks",level:2},{value:"Cosmwasm Contract Execution Format",id:"cosmwasm-contract-execution-format",level:3},{value:"ICS20 packet structure",id:"ics20-packet-structure",level:3},{value:"Execution flow",id:"execution-flow",level:3},{value:"Ack callbacks",id:"ack-callbacks",level:2},{value:"Design",id:"design",level:3},{value:"Use case",id:"use-case",level:3},{value:"Implementation",id:"implementation",level:3},{value:"Callback information in memo",id:"callback-information-in-memo",level:4},{value:"Interface for receiving the Acks and Timeouts",id:"interface-for-receiving-the-acks-and-timeouts",level:4},{value:"Async Acks",id:"async-acks",level:3},{value:"Use case",id:"use-case-1",level:4},{value:"Making contract Acks async",id:"making-contract-acks-async",level:4},{value:"Sending an async ack",id:"sending-an-async-ack",level:4}],d={toc:l};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ibc-hooks"},"IBC Hooks"),(0,o.kt)("h2",{id:"wasm-hooks"},"Wasm Hooks"),(0,o.kt)("p",null,"The wasm hook is an IBC middleware which is used to allow ICS-20 token transfers to initiate contract calls.\nThis allows cross-chain contract calls, that involve token movement.\nThis is useful for a variety of usecases.\nOne of primary importance is cross-chain swaps, which is an extremely powerful primitive."),(0,o.kt)("p",null,"The mechanism enabling this is a ",(0,o.kt)("inlineCode",{parentName:"p"},"memo")," field on every ICS20 transfer packet as of ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/the-interchain-foundation/moving-beyond-simple-token-transfers-d42b2b1dc29b"},"IBC v3.4.0"),".\nWasm hooks is an IBC middleware that parses an ICS20 transfer, and if the ",(0,o.kt)("inlineCode",{parentName:"p"},"memo")," field is of a particular form, executes a wasm contract call. We now detail the ",(0,o.kt)("inlineCode",{parentName:"p"},"memo")," format for ",(0,o.kt)("inlineCode",{parentName:"p"},"wasm")," contract calls, and the execution guarantees provided."),(0,o.kt)("h3",{id:"cosmwasm-contract-execution-format"},"Cosmwasm Contract Execution Format"),(0,o.kt)("p",null,"Before we dive into the IBC metadata format, we show the cosmwasm execute message format, so the reader has a sense of what are the fields we need to be setting in.\nThe cosmwasm ",(0,o.kt)("inlineCode",{parentName:"p"},"MsgExecuteContract")," is defined ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/CosmWasm/wasmd/blob/4fe2fbc8f322efdaf187e2e5c99ce32fd1df06f0/x/wasm/types/tx.pb.go#L340-L349"},"here")," as the following type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},"type MsgExecuteContract struct {\n    // Sender is the actor that committed the message in the sender chain\n    Sender string\n    // Contract is the address of the smart contract\n    Contract string\n    // Msg json encoded message to be passed to the contract\n    Msg RawContractMessage\n    // Funds coins that are transferred to the contract on execution\n    Funds sdk.Coins\n}\n")),(0,o.kt)("p",null,"So we detail where we want to get each of these fields from:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Sender: We cannot trust the sender of an IBC packet, the counterparty chain has full ability to lie about it.\nWe cannot risk this sender being confused for a particular user or module address on Osmosis.\nSo we replace the sender with an account to represent the sender prefixed by the channel and a wasm module prefix.\nThis is done by setting the sender to ",(0,o.kt)("inlineCode",{parentName:"li"},'Bech32(Hash("ibc-wasm-hook-intermediary" || channelID || sender))'),", where the channelId is the channel id on the local chain. "),(0,o.kt)("li",{parentName:"ul"},"Contract: This field should be directly obtained from the ICS-20 packet metadata"),(0,o.kt)("li",{parentName:"ul"},"Msg: This field should be directly obtained from the ICS-20 packet metadata."),(0,o.kt)("li",{parentName:"ul"},"Funds: This field is set to the amount of funds being sent over in the ICS 20 packet. One detail is that the denom in the packet is the counterparty chains representation of the denom, so we have to translate it to Osmosis' representation.")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"WARNING:")),"  Due to a ",(0,o.kt)("a",{parentName:"p",href:"https://twitter.com/SCVSecurity/status/1682329758020022272"},"bug")," in the packet forward middleware, we cannot trust the sender from chains that use PFM. Until that is fixed, we recommend chains to not trust the sender on contracts executed via IBC hooks. ")),(0,o.kt)("p",null,"So our constructed cosmwasm message that we execute will look like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-go"},'msg := MsgExecuteContract{\n    // Sender is the that actor that signed the messages\n    Sender: "osmo1-hash-of-channel-and-sender",\n    // Contract is the address of the smart contract\n    Contract: packet.data.memo["wasm"]["ContractAddress"],\n    // Msg json encoded message to be passed to the contract\n    Msg: packet.data.memo["wasm"]["Msg"],\n    // Funds coins that are transferred to the contract on execution\n    Funds: sdk.NewCoin{Denom: ibc.ConvertSenderDenomToLocalDenom(packet.data.Denom), Amount: packet.data.Amount}\n')),(0,o.kt)("h3",{id:"ics20-packet-structure"},"ICS20 packet structure"),(0,o.kt)("p",null,"So given the details above, we propagate the implied ICS20 packet data structure.\nICS20 is JSON native, so we use JSON for the memo format."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    //... other ibc fields that we don\'t care about\n    "data":{\n        "denom": "denom on counterparty chain (e.g. uatom)",  // will be transformed to the local denom (ibc/...)\n        "amount": "1000",\n        "sender": "addr on counterparty chain", // will be transformed\n        "receiver": "contract addr or blank",\n        "memo": {\n           "wasm": {\n              "contract": "osmo1contractAddr",\n              "msg": {\n                "raw_message_fields": "raw_message_data",\n              }\n            }\n        }\n    }\n}\n')),(0,o.kt)("p",null,"An ICS20 packet is formatted correctly for wasmhooks iff the following all hold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," is not blank"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," is valid JSON"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," has at least one key, with value ",(0,o.kt)("inlineCode",{parentName:"li"},'"wasm"')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'memo["wasm"]')," has exactly two entries, ",(0,o.kt)("inlineCode",{parentName:"li"},'"contract"')," and ",(0,o.kt)("inlineCode",{parentName:"li"},'"msg"')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'memo["wasm"]["msg"]')," is a valid JSON object"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},'receiver == "" || receiver == memo["wasm"]["contract"]'))),(0,o.kt)("p",null,"We consider an ICS20 packet as directed towards wasmhooks iff all of the following hold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," is not blank"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," is valid JSON"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memo")," has at least one key, with name ",(0,o.kt)("inlineCode",{parentName:"li"},'"wasm"'))),(0,o.kt)("p",null,"If an ICS20 packet is not directed towards wasmhooks, wasmhooks doesn't do anything.\nIf an ICS20 packet is directed towards wasmhooks, and is formatted incorrectly, then wasmhooks returns an error."),(0,o.kt)("h3",{id:"execution-flow"},"Execution flow"),(0,o.kt)("p",null,"Pre wasm hooks:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ensure the incoming IBC packet is cryptogaphically valid"),(0,o.kt)("li",{parentName:"ul"},"Ensure the incoming IBC packet is not timed out.")),(0,o.kt)("p",null,"In Wasm hooks, pre packet execution:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ensure the packet is correctly formatted (as defined above)"),(0,o.kt)("li",{parentName:"ul"},"Edit the receiver to be the hardcoded IBC module account")),(0,o.kt)("p",null,"In wasm hooks, post packet execution:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Construct wasm message as defined before"),(0,o.kt)("li",{parentName:"ul"},"Execute wasm message"),(0,o.kt)("li",{parentName:"ul"},"if wasm message has error, return ErrAck"),(0,o.kt)("li",{parentName:"ul"},"otherwise continue through middleware")),(0,o.kt)("h2",{id:"ack-callbacks"},"Ack callbacks"),(0,o.kt)("p",null,"A contract that sends an IBC transfer, may need to listen for the ACK from that packet. To allow\ncontracts to listen on the ack of specific packets, we provide Ack callbacks. "),(0,o.kt)("h3",{id:"design"},"Design"),(0,o.kt)("p",null,"The sender of an IBC transfer packet may specify a callback for when the ack of that packet is received in the memo\nfield of the transfer packet. "),(0,o.kt)("p",null,"Crucially, ",(0,o.kt)("em",{parentName:"p"},"only")," the IBC packet sender can set the callback."),(0,o.kt)("h3",{id:"use-case"},"Use case"),(0,o.kt)("p",null,"The crosschain swaps implementation sends an IBC transfer. If the transfer were to fail, we want to allow the sender\nto be able to retrieve their funds (which would otherwise be stuck in the contract). To do this, we allow users to\nretrieve the funds after the timeout has passed, but without the ack information, we cannot guarantee that the send\nhasn't failed (i.e.: returned an error ack notifying that the receiving change didn't accept it)"),(0,o.kt)("h3",{id:"implementation"},"Implementation"),(0,o.kt)("h4",{id:"callback-information-in-memo"},"Callback information in memo"),(0,o.kt)("p",null,"For the callback to be processed, the transfer packet's memo should contain the following in its JSON:"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},'{"ibc_callback": "osmo1contractAddr"}')),(0,o.kt)("p",null,"The wasm hooks will keep the mapping from the packet's channel and sequence to the contract in storage. When an ack is\nreceived, it will notify the specified contract via a sudo message."),(0,o.kt)("h4",{id:"interface-for-receiving-the-acks-and-timeouts"},"Interface for receiving the Acks and Timeouts"),(0,o.kt)("p",null,"The contract that awaits the callback should implement the following interface for a sudo message:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cw_serde]\npub enum IBCLifecycleComplete {\n    #[serde(rename = "ibc_ack")]\n    IBCAck {\n        /// The source channel (osmosis side) of the IBC packet\n        channel: String,\n        /// The sequence number that the packet was sent with\n        sequence: u64,\n        /// String encoded version of the ack as seen by OnAcknowledgementPacket(..)\n        ack: String,\n        /// Weather an ack is a success of failure according to the transfer spec\n        success: bool,\n    },\n    #[serde(rename = "ibc_timeout")]\n    IBCTimeout {\n        /// The source channel (osmosis side) of the IBC packet\n        channel: String,\n        /// The sequence number that the packet was sent with\n        sequence: u64,\n    },\n}\n\n/// Message type for `sudo` entry_point\n#[cw_serde]\npub enum SudoMsg {\n    #[serde(rename = "ibc_lifecycle_complete")]\n    IBCLifecycleComplete(IBCLifecycleComplete),\n}\n')),(0,o.kt)("h3",{id:"async-acks"},"Async Acks"),(0,o.kt)("p",null,"IBC supports the ability to send an ack back to the sender of the packet asynchronously. This is useful for\ncases where the packet is received, but the ack is not immediately known. For example, if the packet is being\nforwarded to another chain, the ack may not be known until the packet is received on the other chain."),(0,o.kt)("p",null,"Note this ACK does not imply full revertability. It is possible that unrevertable actions have occurred\neven if there is an Ack Error. (This is distinct from the behavior of ICS-20 transfers). If you want to ensure\nrevertability, your contract should be implemented in a way that actions are not finalized until a success ack\nis received."),(0,o.kt)("h4",{id:"use-case-1"},"Use case"),(0,o.kt)("p",null,"Async acks are useful in cases where the contract needs to wait for a response from another chain before\nreturning a result to the caller. "),(0,o.kt)("p",null,"For example, if you want to send tokens to another chain after the contract is executed you need to\nadd a new ibc packet and wait for its ack. "),(0,o.kt)("p",null,"In the synchronous acks case, the caller will receive an ack from the contract before the second packet\nhas been processed. This means that the caller will have to wait (and potentially track) if the second\npacket has been processed successfully or not. "),(0,o.kt)("p",null,"With async acks, you contract can take this responsibility and only send an ack to the caller once the\nsecond packet has been processed"),(0,o.kt)("h4",{id:"making-contract-acks-async"},"Making contract Acks async"),(0,o.kt)("p",null,"To support this, we allow contracts to return an ",(0,o.kt)("inlineCode",{parentName:"p"},"IBCAsync")," response from the function being executed when the\npacket is received. That response specifies that the ack should be handled asynchronously. "),(0,o.kt)("p",null,"Concretely the contract should return:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[cw_serde]\npub struct OnRecvPacketAsyncResponse {\n    pub is_async_ack: bool,\n}\n")),(0,o.kt)("p",null,"if ",(0,o.kt)("inlineCode",{parentName:"p"},"is_async_ack")," is set to true, ",(0,o.kt)("inlineCode",{parentName:"p"},"OnRecvPacket")," will return ",(0,o.kt)("inlineCode",{parentName:"p"},"nil"),' and the ack will not be written. Instead, the\ncontract will be stored as the "ack actor" for the packet so that only that contract is allowed to send an ack\nfor it.'),(0,o.kt)("p",null,"It is up to the contract developers to decide which conditions will trigger the ack to be sent. "),(0,o.kt)("h4",{id:"sending-an-async-ack"},"Sending an async ack"),(0,o.kt)("p",null,"To send the async ack, the contract needs to send the MsgEmitIBCAck message to the chain. This message will\nthen make a sudo call to the contract requesting the ack and write the ack to state. "),(0,o.kt)("p",null,"That message can be specified in the contract as: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(\n    Clone,\n    PartialEq,\n    Eq,\n    ::prost::Message,\n    serde::Serialize,\n    serde::Deserialize,\n    schemars::JsonSchema,\n    CosmwasmExt,\n)]\n#[proto_message(type_url = "/osmosis.ibchooks.MsgEmitIBCAck")]\npub struct MsgEmitIBCAck {\n    #[prost(string, tag = "1")]\n    pub sender: ::prost::alloc::string::String,\n    #[prost(uint64, tag = "2")]\n    pub packet_sequence: u64,\n    #[prost(string, tag = "3")]\n    pub channel: ::prost::alloc::string::String,\n}\n')),(0,o.kt)("p",null,"The contract is expected to implement the following sudo message handler:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cw_serde]\npub enum IBCAsyncOptions {\n    #[serde(rename = "request_ack")]\n    RequestAck {\n        /// The source channel (osmosis side) of the IBC packet\n        source_channel: String,\n        /// The sequence number that the packet was sent with\n        packet_sequence: u64,\n    },\n}\n\n#[cw_serde]\npub enum SudoMsg {\n    #[serde(rename = "ibc_async")]\n    IBCAsync(IBCAsyncOptions),\n}\n')),(0,o.kt)("p",null,"and that sudo call should return an ",(0,o.kt)("inlineCode",{parentName:"p"},"IBCAckResponse"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'#[cw_serde]\n#[serde(tag = "type", content = "content")]\npub enum IBCAck {\n    AckResponse{\n        packet: Packet,\n        contract_ack: ContractAck,\n    },\n    AckError {\n        packet: Packet,\n        error_description: String,\n        error_response: String,\n    }\n}\n')),(0,o.kt)("p",null,"Note: the sudo call is required to potentially allow anyone to send the MsgEmitIBCAck message. For now, however,\nthis is artificially limited so that the message can only be send by the same contract. This could be expanded in\nthe future if needed. "),(0,o.kt)("h1",{id:"repository"},"Repository"),(0,o.kt)("p",null,"For more an in-depth docs and implementation, please visit: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/osmosis-labs/osmosis/tree/main/x/ibc-hooks"},"https://github.com/osmosis-labs/osmosis/tree/main/x/ibc-hooks")))}m.isMDXComponent=!0}}]);