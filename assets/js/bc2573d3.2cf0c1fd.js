"use strict";(self.webpackChunkosmosis_docs=self.webpackChunkosmosis_docs||[]).push([[7567],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var o=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,o)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,o,n=function(e,t){if(null==e)return{};var a,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)a=r[o],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=o.createContext({}),p=function(e){var t=o.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(a),h=n,c=m["".concat(s,".").concat(h)]||m[h]||d[h]||r;return a?o.createElement(c,i(i({ref:t},u),{},{components:a})):o.createElement(c,i({ref:t},u))}));function h(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var p=2;p<r;p++)i[p]=a[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,a)}m.displayName="MDXCreateElement"},35619:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=a(87462),n=(a(67294),a(3905));const r={sidebar_position:9},i="Protorev",l={unversionedId:"features/protorev",id:"features/protorev",title:"Protorev",description:"ProtoRev is a module that:",source:"@site/docs/overview/features/protorev.md",sourceDirName:"features",slug:"/features/protorev",permalink:"/overview/features/protorev",draft:!1,editUrl:"https://github.com/osmosis-labs/docs/tree/main/docs/overview/features/protorev.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Token Factory",permalink:"/overview/features/tokenfactory"}},s={},p=[{value:"Cyclic Arbitrage",id:"cyclic-arbitrage",level:2},{value:"Cyclic Arbitrage Route",id:"cyclic-arbitrage-route",level:2},{value:"Optimal Amount In to Swap",id:"optimal-amount-in-to-swap",level:2},{value:"State Object",id:"state-object",level:2},{value:"TokenPairArbRoutes",id:"tokenpairarbroutes",level:3},{value:"DenomPairToPool",id:"denompairtopool",level:3},{value:"BaseDenoms",id:"basedenoms",level:3},{value:"NumberOfTrades",id:"numberoftrades",level:3},{value:"ProfitsByDenom",id:"profitsbydenom",level:3},{value:"TradesByRoute &amp; ProfitsByRoute",id:"tradesbyroute--profitsbyroute",level:3},{value:"ProtoRevEnabled",id:"protorevenabled",level:3},{value:"AdminAccount",id:"adminaccount",level:3},{value:"DeveloperAccount",id:"developeraccount",level:3},{value:"DaysSinceModuleGenesis",id:"dayssincemodulegenesis",level:3},{value:"DeveloperFees (DEPRECATED IN v16)",id:"developerfees-deprecated-in-v16",level:3},{value:"MaxPoolPointsPerTx",id:"maxpoolpointspertx",level:3},{value:"MaxPoolPointsPerBlock",id:"maxpoolpointsperblock",level:3},{value:"PoolPointCountForBlock",id:"poolpointcountforblock",level:3},{value:"LatestBlockHeight",id:"latestblockheight",level:3},{value:"PoolWeights",id:"poolweights",level:3},{value:"GenesisState",id:"genesisstate",level:3},{value:"Route Generation",id:"route-generation",level:2},{value:"Highest Liquidity Pool Method",id:"highest-liquidity-pool-method",level:3},{value:"Hot Route Method",id:"hot-route-method",level:3},{value:"Pool Rebalancing",id:"pool-rebalancing",level:3},{value:"Governance Proposals",id:"governance-proposals",level:2},{value:"PostHandler",id:"posthandler",level:2},{value:"ExtractSwappedPools",id:"extractswappedpools",level:3},{value:"BuildRoutes",id:"buildroutes",level:3},{value:"IterateRoutes",id:"iterateroutes",level:3},{value:"FindMaxProfitForRoute",id:"findmaxprofitforroute",level:3},{value:"ExecuteTrade",id:"executetrade",level:3},{value:"Execution Guardrails",id:"execution-guardrails",level:2},{value:"Epoch Hook",id:"epoch-hook",level:2},{value:"Highest Liquidity Pools",id:"highest-liquidity-pools",level:3},{value:"Profit Distribution",id:"profit-distribution",level:3},{value:"<strong><code>SetProtoRevAdminAccountProposal</code></strong>",id:"setprotorevadminaccountproposal",level:2},{value:"<strong><code>SetProtoRevEnabledProposal</code></strong>",id:"setprotorevenabledproposal",level:2},{value:"<code>MsgSetDeveloperAccount</code>",id:"msgsetdeveloperaccount",level:2},{value:"<code>MsgSetHotRoutes</code>",id:"msgsethotroutes",level:2},{value:"<strong><code>MsgSetMaxPoolPointsPerTx</code></strong>",id:"msgsetmaxpoolpointspertx",level:2},{value:"<code>MsgSetMaxPoolPointsPerBlock</code>",id:"msgsetmaxpoolpointsperblock",level:2},{value:"<strong><code>MsgSetPoolWeights</code></strong>",id:"msgsetpoolweights",level:2},{value:"<strong><code>MsgSetBaseDenoms</code></strong>",id:"msgsetbasedenoms",level:2},{value:"Enabled",id:"enabled",level:2},{value:"CLI",id:"cli",level:2},{value:"Queries",id:"queries",level:3},{value:"Proposals",id:"proposals",level:3},{value:"gRPC &amp; REST",id:"grpc--rest",level:2},{value:"Queries",id:"queries-1",level:3},{value:"Transactions",id:"transactions-1",level:3},{value:"Events",id:"events",level:2},{value:"<code>types.TypeEvtBackrun</code>",id:"typestypeevtbackrun",level:3}],u={toc:p};function d(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,o.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"protorev"},"Protorev"),(0,n.kt)("h1",{id:"abstract"},"Abstract"),(0,n.kt)("p",null,"ProtoRev is a module that:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Runs during the Posthandler (core trading execution) and Epoch Hook (keeper store updating)"),(0,n.kt)("li",{parentName:"ol"},"In the posthandler of a tx, checks if that tx swaps (has SwapExactAmountIn or SwapExactAmountOut as Msgs)"),(0,n.kt)("li",{parentName:"ol"},"If a tx swaps, generates routes related to the pool swapped against that may contain cyclic arbitrage opportunities after the user\u2019s swap"),(0,n.kt)("li",{parentName:"ol"},"For each route, determines the optimal amount of the asset to swap in that results in maximum amount of the same asset out (profit)"),(0,n.kt)("li",{parentName:"ol"},"Compares profits and selects the route that generates the most profit and is greater than 0"),(0,n.kt)("li",{parentName:"ol"},"Mints the optimal amount of asset to swap in from the Bank module (as determined previously)"),(0,n.kt)("li",{parentName:"ol"},"Executes the MultiHopSwapExactAmountIn with the optimal input amount for the route"),(0,n.kt)("li",{parentName:"ol"},"Burns the same amount of asset previously minted to execute the swap"),(0,n.kt)("li",{parentName:"ol"},"Redistributes the profit captured back to the Osmosis ecosystem based on Governance.")),(0,n.kt)("p",null,"For ecosystem context about the purpose of the module, please see the ProtoRev governance proposal discussion: ",(0,n.kt)("a",{parentName:"p",href:"https://common.xyz/osmosis/discussion/7078-skip-x-osmosis-proposal-to-capture-mev-as-protocol-revenue-on-chain"},"https://common.xyz/osmosis/discussion/7078-skip-x-osmosis-proposal-to-capture-mev-as-protocol-revenue-on-chain")),(0,n.kt)("h1",{id:"concepts"},"Concepts"),(0,n.kt)("h2",{id:"cyclic-arbitrage"},"Cyclic Arbitrage"),(0,n.kt)("p",null,"Cyclic arbitrage is a series of swaps that results in more of the same asset that was initially swapped in. An example of this is as follows:"),(0,n.kt)("p",null,"Assume there exist three pools with the following asset pairs:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"1. A/B\n2. B/C\n3. C/A\n")),(0,n.kt)("p",null,"A user executes a multi-hop swap that swaps between pools 1, 2, and 3 with the following outcome (user inputs 10A into pool 1, and receives 15A from pool 3):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"User -> 10A -> Pool 1 -> 5B -> Pool 2 -> 20C -> Pool 3 -> 15A -> User\n")),(0,n.kt)("p",null,"This series of swaps is known as a cyclic swap because it starts and ends in the same asset. A cyclic swap is known as a cyclic arbitrage swap when the output amount is greater than the input amount, for the same asset."),(0,n.kt)("h2",{id:"cyclic-arbitrage-route"},"Cyclic Arbitrage Route"),(0,n.kt)("p",null,"A Cyclic Arbitrage Route describes an ordered set of pools that need to be swapped through in consecutive order to capture a cyclic arbitrage opportunity. A Cyclic Route can be determined without knowing current reserve ratios of pools by assessing if one can swap in an asset into the series of pools and receive the same asset out. "),(0,n.kt)("p",null,"So for the same pools as the example above, an exhaustive list of Cyclic Routes are as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-python"},"1. A/B\n2. B/C\n3. C/A\n\n(1,2,3) # Asset A in, Asset A Out\n(3,2,1) # Asset A in, Asset A Out\n(3,1,2) # Asset C in, Asset C Out\n(2,1,3) # Asset C in, Asset C Out\n(2,3,1) # Asset B in, Asset B Out\n(1,3,2) # Asset B in, Asset B Out\n")),(0,n.kt)("p",null,"What determines if a Cyclic Route is a Cyclic Arbitrage Route at any given state of the chain (state of pool reserves) is if there exists an amount of an asset to be swapped into the route that results in more of the same asset out (10A in, 10A+ Out)."),(0,n.kt)("h2",{id:"optimal-amount-in-to-swap"},"Optimal Amount In to Swap"),(0,n.kt)("p",null,"When given an ordered route against a specific chain state (state of pool reserves) where a cyclic arbitrage opportunity exists, one must then determine how much to swap in to capture maximum profits (where profits is defined as Asset Out Amount - Asset In Amount). "),(0,n.kt)("p",null,"ProtoRev uses a binary search algorithm to determine the optimal amount in to swap, using functions from the PoolManager module for calculations and swap execution."),(0,n.kt)("h1",{id:"state"},"State"),(0,n.kt)("h2",{id:"state-object"},"State Object"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," module keeps the following objects in state:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"State Object"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"),(0,n.kt)("th",{parentName:"tr",align:null},"Key"),(0,n.kt)("th",{parentName:"tr",align:null},"Values"),(0,n.kt)("th",{parentName:"tr",align:null},"Store"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"TokenPairArbRoutes"),(0,n.kt)("td",{parentName:"tr",align:null},"TokenPairRoutes tracks cyclic arb routes that can be used to create a MultiHopSwap given two denoms"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{1} + []byte{inputDenom} +[]byte{outputDenom}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{TokenPairArbRoutes}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"DenomPairToPool"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the pool ids of the highest liquidity pools matched with a given denom[]byte{2}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{2} + []byte{baseDenom} + []byte{denomToMatch}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{poolID}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"BaseDenoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks all of the base denominations that will be used to construct arbitrage routes"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{3}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{[]BaseDenoms{}}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"NumberOfTrades"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the number of trades protorev has executed"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{4}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{numberOfTrades}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ProfitsByDenom"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the profits protorev has made"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{5} + []byte{tokenDenom}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{sdk.Coin}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"TradesByRoute"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the number of trades the module has executed on a given route"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{6} + []byte{route}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{numberOfTrades}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ProfitsByRoute"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the profits the module has accumulated after trading on a given route"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{7} + []byte{route}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{sdk.Coin}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"DeveloperAccount"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the developer account for protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{8}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{sdk.AccAddress}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"DaysSinceModuleGenesis"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the number of days since the module was initialized. Used to track profits that can be withdrawn by the developer account"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{9}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{uint}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"DeveloperFees"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the profits that the developer account can withdraw"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{10} + []byte{tokenDenom}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{sdk.Coin}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"MaxPoolPointsPerTx"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the maximum number of pool points that can be consumed per tx"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{11}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{uint64}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"MaxPoolPointsPerBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the maximum number of pool points that can be consumed per block"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{12}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{uint64}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"PoolPointCountForBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the number of pool points that have been consumed in this block"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{13}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{uint64}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"LatestBlockHeight"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the latest recorded block height"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{14}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{uint64}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"PoolWeights"),(0,n.kt)("td",{parentName:"tr",align:null},"Tracks the weights (pool points) of the different pool types"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{15}"),(0,n.kt)("td",{parentName:"tr",align:null},"[]byte{PoolWeights}"),(0,n.kt)("td",{parentName:"tr",align:null},"KV")))),(0,n.kt)("h3",{id:"tokenpairarbroutes"},"TokenPairArbRoutes"),(0,n.kt)("p",null,"TokenPairArbRoutes are cyclic arbitrage routes that are not going to be captured by the highest liquidity method (described in state transitions below). If there is a cyclic arbitrage route that is frequently being utilized by searchers, ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," can manually enter this route - through the admin account - and allow it to be used for trading. Each TokenPairArbRoutes object tracks a directional swap of two assets, and associates the swap with cyclic routes. When the module sees a swap of (",(0,n.kt)("inlineCode",{parentName:"p"},"token_in"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"token_out"),"), it will extract the ",(0,n.kt)("inlineCode",{parentName:"p"},"arb_routes")," that should be used and will simulate trades and execute them if profitable."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// TokenPairArbRoutes tracks all of the hot routes for a given pair of tokens\nmessage TokenPairArbRoutes {\n  option (gogoproto.equal) = true;\n\n  // Stores all of the possible hot paths for a given pair of tokens\n  repeated Route arb_routes = 1;\n  // Token denomination of the first asset\n  string token_in = 2;\n  // Token denomination of the second asset\n  string token_out = 3;\n}\n\n// Route is a hot route for a given pair of tokens\nmessage Route {\n  option (gogoproto.equal) = true;\n\n  // The pool IDs that are traversed in the directed cyclic graph (traversed left\n  // -> right)\n  repeated Trade trades = 1;\n  // The step size that will be used to find the optimal swap amount in the\n  // binary search\n  string step_size = 2 [\n    (gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int",\n    (gogoproto.nullable) = true\n  ];\n}\n\n// Trade is a single trade in a route\nmessage Trade {\n  option (gogoproto.equal) = true;\n\n  // The pool IDs that are traversed in the directed cyclic graph (traversed left\n  // -> right)\n  uint64 pool = 1;\n  // The denom of token A that is traded\n  string token_in = 2;\n  // The denom of token B that is traded\n  string token_out = 3;\n}\n')),(0,n.kt)("h3",{id:"denompairtopool"},"DenomPairToPool"),(0,n.kt)("p",null,"DenomPairToPool takes in a base denomination (read below) \u2013 denom that is used to build routes (ex. osmo, atom, usdc) \u2013 and a denom to match (akash, juno) and returns the highest liquidity pool id between the pair of denominations. For example, an input might look like (osmo, juno) \u2014> poolID: 5. This store is directly tied to the highest liquidity method (described in state transitions below). Each base denomination is going to have its own set of denominations it maps to."),(0,n.kt)("h3",{id:"basedenoms"},"BaseDenoms"),(0,n.kt)("p",null,"BaseDenoms are the denominations that are used to build the highest liquidity routes. This will be configurable by the admin account, but will always maintain at least\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"uosmo"),"\xa0as a base denom. A base denom just means the denomination that will be used to start and end a cyclic arbitrage route. Base denoms can be added on as needed basis. "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("em",{parentName:"strong"},"NOTE")),": BaseDenoms do have a priority that is directly tied down to the order in the list of base denoms that are used i.e. BaseDenoms that are closer to the front of the list will likely be simulated and executed more often than those later in the list. This is done by design so that we can prioritize certain denoms over others in order to simulate and execute the most profitable trades."),(0,n.kt)("h3",{id:"numberoftrades"},"NumberOfTrades"),(0,n.kt)("p",null,"This will store the total number of arbitrage trades that\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev"),"\xa0has executed since genesis. This gets incremented every time the module executes a trade."),(0,n.kt)("h3",{id:"profitsbydenom"},"ProfitsByDenom"),(0,n.kt)("p",null,"This will store the profits ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," has accumulated for a given denom."),(0,n.kt)("h3",{id:"tradesbyroute--profitsbyroute"},"TradesByRoute & ProfitsByRoute"),(0,n.kt)("p",null,"These stores allow users and researchers to query the number of cyclic arbitrage trades that have been executed by\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev"),"\xa0on an cyclic arbitrage route as well as all of the profits captured on that same route. Routes are denoted by the pool ids in the route i.e. []uint64{1,2,3}."),(0,n.kt)("h3",{id:"protorevenabled"},"ProtoRevEnabled"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," can be enabled or disabled through governance. As a proposal is a stateful change, we store whether the module is currently enabled or disabled in the module."),(0,n.kt)("h3",{id:"adminaccount"},"AdminAccount"),(0,n.kt)("p",null,"The admin account is set through governance and has permissions to set hot routes, the maximum number of pool points per transaction, maximum number of pool points per block, pool type weights, base denoms and the developer account. On genesis, the admin account is set to a trusted address that is stored on a ledger - currently configured to be the Skip dev team's address. Note that governance has full ability to change this live on-chain, and this admin can at most prevent ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," from working. All the admin account's controls have limits, so it can't lead to a chain halt, excess processing time or prevention of swaps."),(0,n.kt)("h3",{id:"developeraccount"},"DeveloperAccount"),(0,n.kt)("p",null,"The developer account is set through a MsgSetDeveloperAccount tx. This is the account that will be able to withdraw a portion of the profits from ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," as specified by the Osmosis \u2194\xa0Skip proposal. Only the admin account has permission to make this message."),(0,n.kt)("h3",{id:"dayssincemodulegenesis"},"DaysSinceModuleGenesis"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," will distribute 20% of profits to the developer account in year 1, 10% of profits in year 2, and 5% thereafter. To track how much profit can be distributed to the developer account at any given moment, we store the amount of days since module genesis."),(0,n.kt)("h3",{id:"developerfees-deprecated-in-v16"},"DeveloperFees (DEPRECATED IN v16)"),(0,n.kt)("p",null,"DeveloperFees tracks the total amount of profit that can be withdrawn by the developer account. These fees are sent to the developer account, if set, every week through the ",(0,n.kt)("inlineCode",{parentName:"p"},"epoch")," hook. If unset, the funds are held in the module account. All ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," profits are going to be stored on the module account."),(0,n.kt)("h3",{id:"maxpoolpointspertx"},"MaxPoolPointsPerTx"),(0,n.kt)("p",null,"A pool point roughly corresponds to a millisecond of trading simulation and execution time. In order to bound the compute time of ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," , we set a maximum number of pool points (execution time) per transaction and per block. MaxPoolPointsPerTx tracks the maximum number of pool points that can be consumed in a given transaction. This is configurable (but bounded) by the admin account. We limit the number of pool points per transaction so that all\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev"),"\xa0execution is not limited to the top of the block."),(0,n.kt)("h3",{id:"maxpoolpointsperblock"},"MaxPoolPointsPerBlock"),(0,n.kt)("p",null,"MaxPoolPointsPerBlock tracks the maximum number of pool points that can be consumed in a given block. This is configurable (but bounded) by the admin account. We limit the number of pool points per block so that the execution time of the\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev"),"\xa0posthandler is reasonably bounded to ensure that block time remains as is."),(0,n.kt)("h3",{id:"poolpointcountforblock"},"PoolPointCountForBlock"),(0,n.kt)("p",null,"PoolPointCountForBlock tracks the number of pool points that have been consumed in the current block. Used to ensure that the module is not slowing down block speed."),(0,n.kt)("h3",{id:"latestblockheight"},"LatestBlockHeight"),(0,n.kt)("p",null,"LatestBlockHeight tracks the latest recorded block height. This is used to update and reset the pool point count within a block and after new blocks are proposed."),(0,n.kt)("h3",{id:"poolweights"},"PoolWeights"),(0,n.kt)("p",null,"PoolWeights assigns each pool type to a number of pool points it will approximately consume. This tracks the pool points or weight of each pool type that can be traversed. This distinction is necessary because different pool types have different simulation and execution times."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// PoolWeights contains the weights of all of the different pool types. This\n// distinction is made and necessary because the execution time ranges\n// significantly between the different pool types. Each weight roughly\n// corresponds to the amount of time (in ms) it takes to execute a swap on that\n// pool type.\ntype PoolWeights struct {\n    // The weight of a stableswap pool\n    StableWeight uint64 `protobuf:"varint,1,opt,name=stable_weight,json=stableWeight,proto3" json:"stable_weight,omitempty"`\n    // The weight of a balancer pool\n    BalancerWeight uint64 `protobuf:"varint,2,opt,name=balancer_weight,json=balancerWeight,proto3" json:"balancer_weight,omitempty"`\n    // The weight of a concentrated pool\n    ConcentratedWeight uint64 `protobuf:"varint,3,opt,name=concentrated_weight,json=concentratedWeight,proto3" json:"concentrated_weight,omitempty"`\n}\n')),(0,n.kt)("h3",{id:"genesisstate"},"GenesisState"),(0,n.kt)("p",null,"There is only one configurable parameter for the genesis state \u2014> whether protorev is enabled or not."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// GenesisState defines the protorev module\'s genesis state.\ntype GenesisState struct {\n    // Module Parameters\n    Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`\n}\n')),(0,n.kt)("h1",{id:"state-transitions"},"State Transitions"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"protorev")," module triggers state transitions in the ",(0,n.kt)("inlineCode",{parentName:"p"},"postHandler")," , governance proposals, and admin account transactions. After each ",(0,n.kt)("inlineCode",{parentName:"p"},"sdk.Tx"),", the ",(0,n.kt)("inlineCode",{parentName:"p"},"postHandler")," will determine whether there were any ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountIn")," or ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSwapExactAmountOut")," in the transaction. If so, the module gets all of the pools that were used in the swap(s), temporarily stores the pool ids accessed along with their respective tokenIn/tokenOut denoms, and then builds cyclic arbitrage routes for each pool swapped against."),(0,n.kt)("h2",{id:"route-generation"},"Route Generation"),(0,n.kt)("p",null,"There are two primary methods for route generation: ",(0,n.kt)("strong",{parentName:"p"},"Highest Liquidity Pools")," and ",(0,n.kt)("strong",{parentName:"p"},"Hot Routes"),"."),(0,n.kt)("h3",{id:"highest-liquidity-pool-method"},"Highest Liquidity Pool Method"),(0,n.kt)("p",null,"The highest liquidity pool method will always create cyclic arbitrage routes that have three pools. The routes that are created will always start and end with one of the denominations that are stored in BaseDenoms. The pool swapped against that the ",(0,n.kt)("inlineCode",{parentName:"p"},"postHandler")," processes will always be the 2nd pool in the three-pool cyclic arbitrage route. "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Highest Liquidity Pools:")," Updated via the daily epoch, the module iterates through all the pools and stores the highest liquidity pool for every asset that pairs with any of the base denominations the module stores (for example, the osmo/juno key will have a single pool id stored, that pool id having the most liquidity out of all the osmo/juno pools). New base denominations can be added or removed on an as needed basis by the admin account. A base denomination is just another way of describing the denomination we want to use for cyclic arbitrage. This store is then used to create routes at runtime after analyzing a swap. This store is updated through the ",(0,n.kt)("inlineCode",{parentName:"p"},"epoch")," hook and when the admin account submits a ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSetBaseDenoms")," tx."),(0,n.kt)("p",null,"The simplest way to conceptualize how the route is generated is by the following example. Assume we have two base denominations that ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," is currently tracking."),(0,n.kt)("p",null,"BaseDenoms"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Osmosis"),(0,n.kt)("li",{parentName:"ul"},"Atom")),(0,n.kt)("p",null,"Lets say the ",(0,n.kt)("inlineCode",{parentName:"p"},"postHandler")," receives a transaction that contains a swap of ",(0,n.kt)("strong",{parentName:"p"},"Juno")," \u2014> ",(0,n.kt)("strong",{parentName:"p"},"Akash")," on pool ",(0,n.kt)("strong",{parentName:"p"},"4"),". In this case, the module will attempt to create three-pool route where a base denomination is on either side of the route. For example, a route that it might create is"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Osmosis \u2014> Akash (on pool 1), Akash \u2014> Juno (on pool 4), Juno \u2014> Osmosis (on pool 2)")),(0,n.kt)("p",null,"It does so by finding the highest liquidity pool between (Osmosis, Akash) \u2014> pool 1 and the highest liquidity pool between (Osmosis, Juno) \u2014> pool 2. If there is no highest liquidity pool pair between (Osmosis, Juno) or (Osmosis, Akash), no route will be generated."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"NOTE: Cyclic arbitrage routes will always go in the opposite direction of the original swap i.e. in this case we see Juno \u2014> Akash so we know that the route must include a swap of Akash \u2014> Juno.")),(0,n.kt)("p",null,"The same line of reasoning exists for Atom. ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," will attempt to find the highest liquidity pool between (Atom, Akash) and (Atom, Juno). If these pools exist, they will be added to the list of routes that can be simulated later in the pipeline. If not, the route is discarded."),(0,n.kt)("p",null,"In both cases, the route that is built will always surround the pool of the original swap that was made. However, we allow for more flexibility in route generation as the highest liquidity method may not be optimal, hence the additional of hot routes."),(0,n.kt)("h3",{id:"hot-route-method"},"Hot Route Method"),(0,n.kt)("p",null,"Populated through the admin account, the module\u2019s keeper holds a KV store that associates token pairs (for example, osmo/juno) to the routes that result in a high percentage of arbitrage profit on Osmosis (as determined by external analysis)."),(0,n.kt)("p",null,"The purpose of storing Hot Routes is a recognition that the Highest Liquidity Pool method may not present the best arbitrage routes. As such, hot routes can be configured by the admin account to store additional routes that may be more effective at capturing arbitrage opportunities. Each hot route will store a placeholder for where the current swapped pool will fit into the trade."),(0,n.kt)("h3",{id:"pool-rebalancing"},"Pool Rebalancing"),(0,n.kt)("p",null,"Now that we have a list of cyclic routes for each pool swapped by the user\u2019s tx, we then determine if any of the routes are profitable. We determine this using a binary search algorithm that finds the amount of the asset to swap in that results in the most of that same asset out. We then calculate profits by taking the difference between the amount of the asset out and amount of the asset in. By iterating through the routes and storing the route, optimal input amount, and profit of the route with the highest profit > 0, we are left with the route and amount to execute the MultiHopSwap against."),(0,n.kt)("p",null,"Each swap will generate its own set of routes and ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," will execute only the most profitable route."),(0,n.kt)("p",null,"The module mints the optimal input amount of the coin to swap in from the ",(0,n.kt)("inlineCode",{parentName:"p"},"bankkeeper")," to the ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," module account, executes the MultiHopSwap by interacting with the ",(0,n.kt)("inlineCode",{parentName:"p"},"x/poolmanager")," module, burns the optimal input amount of the coin minted to execute the MultiHopSwap, and sends subsequent profits to the module account."),(0,n.kt)("h2",{id:"governance-proposals"},"Governance Proposals"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," implements two different governance proposals. "),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"SetProtoRevAdminAccountProposal")),(0,n.kt)("p",null,"As the landscape of pools on Osmosis evolves, an admin account will be able to add and remove routes for ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," to check for cyclic arbitrage opportunities along with several other optimization txs. Largely, the purpose of maintaining hot routes is to reduce the amount of computation that would otherwise be required to determine optimal paths at runtime. "),(0,n.kt)("p",null,"This proposal is put in place in case the admin account needs to be transferred over. However, as mentioned above, it will be initialized to a trusted address on genesis."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"SetProtoRevEnabledProposal")),(0,n.kt)("p",null,"This proposal type allows the chain to turn the module on or off. This is meant to be used as a fail safe in the case stakers and the chain decide to turn the module off. This might be used to halt the execution of trades in the case that the ",(0,n.kt)("inlineCode",{parentName:"p"},"x/gamm")," module has significant upgrades that might produce unexpected behavior from the module."),(0,n.kt)("h2",{id:"posthandler"},"PostHandler"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"postHandler")," extracts pools that were swapped in a transaction and determines if there is a cyclic arbitrage opportunity. If so, the handler will find an optimal route and execute it - rebalancing the pool and returning arbitrage profits to the module account."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Check if the module is enabled.",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"If the module is disabled, nothing happens."))),(0,n.kt)("li",{parentName:"ol"},"Extract all pools that were traded on in the transaction (",(0,n.kt)("inlineCode",{parentName:"li"},"ExtractSwappedPools"),") as well as the direction of the trade."),(0,n.kt)("li",{parentName:"ol"},"Create cyclic arbitrage routes for each of the swaps above (",(0,n.kt)("inlineCode",{parentName:"li"},"BuildRoutes"),")"),(0,n.kt)("li",{parentName:"ol"},"For each feasible route, determine if there is a cyclic arbitrage opportunity (",(0,n.kt)("inlineCode",{parentName:"li"},"IterateRoutes"),")",(0,n.kt)("ol",{parentName:"li"},(0,n.kt)("li",{parentName:"ol"},"Determine the optimal amount to swap in and its respective profits via binary search over range of potential input amounts (",(0,n.kt)("inlineCode",{parentName:"li"},"FindMaxProfitForRoute"),")"),(0,n.kt)("li",{parentName:"ol"},"Compare profits of each route, keep the best route and input amount with the highest profit"))),(0,n.kt)("li",{parentName:"ol"},"If the best route and input amount has a profit > 0, execute the trade (",(0,n.kt)("inlineCode",{parentName:"li"},"ExecuteTrade"),") and rebalance the pools on-behalf of the chain through the ",(0,n.kt)("inlineCode",{parentName:"li"},"poolmanagerkeeper")," (",(0,n.kt)("inlineCode",{parentName:"li"},"MultiHopSwapExactAmountIn"),")"),(0,n.kt)("li",{parentName:"ol"},"Keep the profits in the module\u2019s account for subsequent distribution.")),(0,n.kt)("h3",{id:"extractswappedpools"},"ExtractSwappedPools"),(0,n.kt)("p",null,"Checks if there were any swaps made on pools in a transaction, returning the pool ids and input/output denoms for each pool that was traded on."),(0,n.kt)("h3",{id:"buildroutes"},"BuildRoutes"),(0,n.kt)("p",null,"BuildRoutes takes a token pair (input and output denom) as well as the pool id and returns a list of routes for that token pair that potentially contain a cyclic arbitrage opportunity, populated via the Hot Route and Highest Liquidity Pools method as described above."),(0,n.kt)("h3",{id:"iterateroutes"},"IterateRoutes"),(0,n.kt)("p",null,"IterateRoutes iterates through a list of routes, determining the route and input amount that results in the highest cyclic arbitrage profits.."),(0,n.kt)("h3",{id:"findmaxprofitforroute"},"FindMaxProfitForRoute"),(0,n.kt)("p",null,"This will take in a route and determine the optimal amount to swap in to maximize profits, given the reserves of all of the pools that are swapped against in the route. The bounds of the binary search are dynamic and update per route (see ",(0,n.kt)("inlineCode",{parentName:"p"},"UpdateSearchRangeIfNeeded"),") based on how computationally expensive (in terms of gas) swapping can be on that route. For instance, moving across several ticks on a concentrated pool is relatively expensive, so the bounds of the binary search with a route that includes that pool type may be smaller than a route that does not include that pool type."),(0,n.kt)("h3",{id:"executetrade"},"ExecuteTrade"),(0,n.kt)("p",null,"Execute trade takes the route and optimal input amount as params, mints the optimal amount of input coin, executes the swaps via ",(0,n.kt)("inlineCode",{parentName:"p"},"poolmanagerKeeper"),"\u2019s ",(0,n.kt)("inlineCode",{parentName:"p"},"MultiHopSwapExactAmountIn"),", and then burns the amount of coins originally minted, storing the profits in it\u2019s own module account."),(0,n.kt)("p",null,"This will also update various trading statistics in the module\u2019s store. It will update the total number of trades the module has executed, total profits captured, profits made on this specific route, share of profits the developer account can withdraw, and more."),(0,n.kt)("h2",{id:"execution-guardrails"},"Execution Guardrails"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," is bounded and limited in the number of trades the module can execute per block. The purpose of doing so is to ensure that the current block time does not substantially change and that the module does not introduce a new attack vector. "),(0,n.kt)("p",null,"Execution is currently limited in the following ways"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"The binary search method for finding input amounts is bounded by some number of iterations."),(0,n.kt)("li",{parentName:"ol"},"The number of routes that can be traversed in a given transaction is bounded by some number."),(0,n.kt)("li",{parentName:"ol"},"The number of routes that can be traversed in a given block is bounded by some number.")),(0,n.kt)("h1",{id:"hooks"},"Hooks"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," module implements epoch hooks in order to trigger the recalculation of the highest liquidity pools paired with any of the base denominations, manages the distribution of developer profits over time, and updates pool point information."),(0,n.kt)("h2",{id:"epoch-hook"},"Epoch Hook"),(0,n.kt)("p",null,"The Epoch hook allows the module to update the information listed above using the epoch identifier ",(0,n.kt)("inlineCode",{parentName:"p"},"day"),". "),(0,n.kt)("h3",{id:"highest-liquidity-pools"},"Highest Liquidity Pools"),(0,n.kt)("p",null,"As described above, one method of determining cyclic arbitrage opportunities is to use the highest liquidity pools paired with any base denomination. While this calculation is done on genesis (with only Osmo configured), the pools may restructure over time and new tokens may end up being traded heavily with the base denominations. As such, it is necessary to update this over time so that the module\u2019s logic in determining cyclic arbitrage opportunities is most optimal and updated. Using the ",(0,n.kt)("inlineCode",{parentName:"p"},"AfterEpochEnd")," hook in combination with the ",(0,n.kt)("inlineCode",{parentName:"p"},"day")," epoch identifier, we are able to successfully update the pool information every day. At runtime, ",(0,n.kt)("inlineCode",{parentName:"p"},"UpdatePools")," will be executed and all of the internal pool info will be updated."),(0,n.kt)("h3",{id:"profit-distribution"},"Profit Distribution"),(0,n.kt)("p",null,"Profits accumulated by the module will be partially distributed to the developers that built the module in accordance with the governance proposal that was passed: year 1 is 20% of profits, year 2 is 10%, and subsequent years is 5%."),(0,n.kt)("p",null,"In order to track how much profit the developers can withdraw at any given moment, the module tracks the number of days since module genesis. This gets incremented in the epoch hook after every day. When a trade gets executed by the module, the module will determine how much of the profit from the trade the developers can receive by using ",(0,n.kt)("inlineCode",{parentName:"p"},"daysSinceModuleGenesis")," in a simple calculation. "),(0,n.kt)("p",null,"If the developer account is not set (which it is not on genesis), all funds are held in the module account. Once the developer address is set by the admin account, the developer address will start to automatically receive a share of profits after every trade. The distribution of funds from the module account is done through ",(0,n.kt)("inlineCode",{parentName:"p"},"SendDeveloperFees"),"."),(0,n.kt)("h1",{id:"governance-proposals-1"},"Governance Proposals"),(0,n.kt)("p",null,"This section defines the\xa0governance proposals that result in the state transitions defined on the previous section."),(0,n.kt)("h2",{id:"setprotorevadminaccountproposal"},(0,n.kt)("strong",{parentName:"h2"},(0,n.kt)("inlineCode",{parentName:"strong"},"SetProtoRevAdminAccountProposal"))),(0,n.kt)("p",null,"A gov ",(0,n.kt)("inlineCode",{parentName:"p"},"content")," type to set the admin account which will be overseeing the selection of hot routes, developer account, and more. Governance users vote on this proposal and it automatically executes the custom handler for ",(0,n.kt)("inlineCode",{parentName:"p"},"SetProtoRevAdminAccountProposal")," when the vote passes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// SetProtoRevAdminAccountProposal is a gov Content type to set the admin\n// account that will receive permissions to alter hot routes\ntype SetProtoRevAdminAccountProposal struct {\n    Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`\n    Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`\n    Account     string `protobuf:"bytes,3,opt,name=account,proto3" json:"account,omitempty"`\n}\n')),(0,n.kt)("p",null,"The proposal content stateless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The account entered is not a valid bech32 address.")),(0,n.kt)("h2",{id:"setprotorevenabledproposal"},(0,n.kt)("strong",{parentName:"h2"},(0,n.kt)("inlineCode",{parentName:"strong"},"SetProtoRevEnabledProposal"))),(0,n.kt)("p",null,"A gov ",(0,n.kt)("inlineCode",{parentName:"p"},"content")," type to enable or disable the ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," module. Governance users vote on this proposal and it automatically executes the custom handler for ",(0,n.kt)("inlineCode",{parentName:"p"},"SetProtoRevEnabledProposal")," when the vote passes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// SetProtoRevEnabledProposal is a gov Content type to update the proto rev\n// enabled field in the params\ntype SetProtoRevEnabledProposal struct {\n    Title       string `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`\n    Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`\n    Enabled     bool   `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`\n}\n')),(0,n.kt)("p",null,"The proposal content stateless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The entered field to ",(0,n.kt)("inlineCode",{parentName:"li"},"enabled")," is not a boolean.")),(0,n.kt)("h1",{id:"transactions"},"Transactions"),(0,n.kt)("p",null,"This section defines the\xa0",(0,n.kt)("inlineCode",{parentName:"p"},"sdk.Msg")," concrete types that result in the state transitions defined on the previous section."),(0,n.kt)("h2",{id:"msgsetdeveloperaccount"},(0,n.kt)("inlineCode",{parentName:"h2"},"MsgSetDeveloperAccount")),(0,n.kt)("p",null,"The admin account broadcasts a ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSetDeveloperAccount")," to set the developer account."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetDeveloperAccount defines the Msg/SetDeveloperAccount request type.\ntype MsgSetDeveloperAccount struct {\n    // admin is the account that is authorized to set the developer account.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // developer_account is the account that will receive a portion of the profit\n    // from the protorev module.\n    DeveloperAccount string `protobuf:"bytes,2,opt,name=developer_account,json=developerAccount,proto3" json:"developer_account,omitempty"`\n}\n')),(0,n.kt)("p",null,"Message stateless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"The developer account is not a valid bech32 address")),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same")),(0,n.kt)("h2",{id:"msgsethotroutes"},(0,n.kt)("inlineCode",{parentName:"h2"},"MsgSetHotRoutes")),(0,n.kt)("p",null,"The admin account broadcasts a ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSetHotRoutes")," to set the hot routes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetHotRoutes defines the Msg/SetHotRoutes request type.\ntype MsgSetHotRoutes struct {\n    // admin is the account that is authorized to set the hot routes.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // hot_routes is the list of hot routes to set.\n    HotRoutes []*TokenPairArbRoutes `protobuf:"bytes,2,rep,name=hot_routes,json=hotRoutes,proto3" json:"hot_routes,omitempty"`\n}\n')),(0,n.kt)("p",null,"Message statless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"The hot routes are not valid",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The starting and ending denominations for each route must be the same"),(0,n.kt)("li",{parentName:"ul"},"The routes in between must have valid swaps i.e. a \u2192 b, b \u2192 c, c \u2192 a and not a \u2192 b, c \u2192 b, b \u2192 a"),(0,n.kt)("li",{parentName:"ul"},"None of the routes can be nil"),(0,n.kt)("li",{parentName:"ul"},"The step size must be set for each route  - the step size is used in the binary search method"),(0,n.kt)("li",{parentName:"ul"},"There must be at least two hops in each route"),(0,n.kt)("li",{parentName:"ul"},"There are duplicate token pairs in the msg")))),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"NewMsgSetHotRoutes"))),(0,n.kt)("h2",{id:"msgsetmaxpoolpointspertx"},(0,n.kt)("strong",{parentName:"h2"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetMaxPoolPointsPerTx"))),(0,n.kt)("p",null,"The admin account broadcasts a ",(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetMaxPoolPointsPerTx"))," to set the maximum number of pool points that can consumed per transaction."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetMaxPoolPointsPerTx defines the Msg/SetMaxPoolPointsPerTx request type.\ntype MsgSetMaxPoolPointsPerTx struct {\n    // admin is the account that is authorized to set the max pool points per tx.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // max_pool_points_per_tx is the maximum number of pool points that can be\n    // consumed per transaction.\n    MaxPoolPointsPerTx uint64 `protobuf:"varint,2,opt,name=max_pool_points_per_tx,json=maxPoolPointsPerTx,proto3" json:"max_pool_points_per_tx,omitempty"`\n}\n')),(0,n.kt)("p",null,"Message statless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"The MaxPoolPointsPerTx is out of range of the limits we hardcode")),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same")),(0,n.kt)("h2",{id:"msgsetmaxpoolpointsperblock"},(0,n.kt)("inlineCode",{parentName:"h2"},"MsgSetMaxPoolPointsPerBlock")),(0,n.kt)("p",null,"The admin account broadcasts a ",(0,n.kt)("inlineCode",{parentName:"p"},"MsgSetMaxPoolPointsPerBlock")," to set the maximum number of pool points that can consumed per block."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetMaxPoolPointsPerBlock defines the Msg/SetMaxPoolPointsPerBlock request\n// type.\ntype MsgSetMaxPoolPointsPerBlock struct {\n    // admin is the account that is authorized to set the max pool points per\n    // block.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // max_pool_points_per_block is the maximum number of pool points that can be\n    // consumed per block.\n    MaxPoolPointsPerBlock uint64 `protobuf:"varint,2,opt,name=max_pool_points_per_block,json=maxPoolPointsPerBlock,proto3" json:"max_pool_points_per_block,omitempty"`\n}\n')),(0,n.kt)("p",null,"Message statless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"The MaxRoutesPerBlock is out of range of the limits we hardcode")),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same")),(0,n.kt)("h2",{id:"msgsetpoolweights"},(0,n.kt)("strong",{parentName:"h2"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetPoolWeights"))),(0,n.kt)("p",null,"The admin account broadcasts a\xa0",(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetPoolWeights"))," to set the pool weights. The pool weights roughly correspond to the execution time of a swap on that pool type (stable, balancer, concentrated)."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetPoolWeights defines the Msg/SetPoolWeights request type.\ntype MsgSetPoolWeights struct {\n    // admin is the account that is authorized to set the pool weights.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // pool_weights is the list of pool weights to set.\n    PoolWeights *PoolWeights `protobuf:"bytes,2,opt,name=pool_weights,json=poolWeights,proto3" json:"pool_weights,omitempty"`\n}\n\n// PoolWeights contains the weights of all of the different pool types. This\n// distinction is made and necessary because the execution time ranges\n// significantly between the different pool types. Each weight roughly\n// corresponds to the amount of time (in ms) it takes to execute a swap on that\n// pool type.\ntype PoolWeights struct {\n    // The weight of a stableswap pool\n    StableWeight uint64 `protobuf:"varint,1,opt,name=stable_weight,json=stableWeight,proto3" json:"stable_weight,omitempty"`\n    // The weight of a balancer pool\n    BalancerWeight uint64 `protobuf:"varint,2,opt,name=balancer_weight,json=balancerWeight,proto3" json:"balancer_weight,omitempty"`\n    // The weight of a concentrated pool\n    ConcentratedWeight uint64 `protobuf:"varint,3,opt,name=concentrated_weight,json=concentratedWeight,proto3" json:"concentrated_weight,omitempty"`\n}\n')),(0,n.kt)("p",null,"Message statless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"Any of the pool weights is not set or is less than or equal to 0.")),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same")),(0,n.kt)("h2",{id:"msgsetbasedenoms"},(0,n.kt)("strong",{parentName:"h2"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetBaseDenoms"))),(0,n.kt)("p",null,"The admin account broadcasts a\xa0",(0,n.kt)("strong",{parentName:"p"},(0,n.kt)("inlineCode",{parentName:"strong"},"MsgSetBaseDenoms"))," to set the base denominations the module will use to create cyclic arbitrage routes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// MsgSetBaseDenoms defines the Msg/SetBaseDenoms request type.\ntype MsgSetBaseDenoms struct {\n    // admin is the account that is authorized to set the base denoms.\n    Admin string `protobuf:"bytes,1,opt,name=admin,proto3" json:"admin,omitempty"`\n    // base_denoms is the list of base denoms to set.\n    BaseDenoms []*BaseDenom `protobuf:"bytes,2,rep,name=base_denoms,json=baseDenoms,proto3" json:"base_denoms,omitempty"`\n}\n\n// BaseDenom represents a single base denom that the module uses for its\n// arbitrage trades. It contains the denom name alongside the step size of the\n// binary search that is used to find the optimal swap amount\ntype BaseDenom struct {\n    // The denom i.e. name of the base denom (ex. uosmo)\n    Denom string `protobuf:"bytes,1,opt,name=denom,proto3" json:"denom,omitempty"`\n    // The step size of the binary search that is used to find the optimal swap\n    // amount\n    StepSize github_com_cosmos_cosmos_sdk_types.Int `protobuf:"bytes,2,opt,name=step_size,json=stepSize,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"step_size"`\n}\n')),(0,n.kt)("p",null,"Message statless validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not a valid bech32 address"),(0,n.kt)("li",{parentName:"ul"},"The signature of the user does not match the admin account\u2019s"),(0,n.kt)("li",{parentName:"ul"},"Osmosis is not the first base denom in the list"),(0,n.kt)("li",{parentName:"ul"},"The step size for any of the base denoms is not set"),(0,n.kt)("li",{parentName:"ul"},"There are duplicate base denoms")),(0,n.kt)("p",null,"Message stateful validation fails if:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The admin is not set in state"),(0,n.kt)("li",{parentName:"ul"},"The admin entered in the message does not match the admin on chain"),(0,n.kt)("li",{parentName:"ul"},"The admin\u2019s signatures are not the same")),(0,n.kt)("h1",{id:"parameters"},"Parameters"),(0,n.kt)("p",null,"Tracks whether the module is enabled on genesis."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// Params defines the parameters for the module.\ntype Params struct {\n    // Boolean whether the module is going to be enabled\n    Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`\n}\n')),(0,n.kt)("h2",{id:"enabled"},"Enabled"),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"Enabled")," parameters toggles all state transitions in the module. When the parameter is disabled, it will prevent all module functionality. "),(0,n.kt)("h1",{id:"clients"},"Clients"),(0,n.kt)("h2",{id:"cli"},"CLI"),(0,n.kt)("p",null,"Find below a lost of ",(0,n.kt)("inlineCode",{parentName:"p"},"osmosisd")," commands added with the ",(0,n.kt)("inlineCode",{parentName:"p"},"x/protorev")," module. A CLI command can look like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-bash"},"osmosisd query protorev params\n")),(0,n.kt)("h3",{id:"queries"},"Queries"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Command"),(0,n.kt)("th",{parentName:"tr",align:null},"Subcommand"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"params"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the parameters of the module")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"number-of-trades"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of cyclic arbitrage trades ProtoRev has executed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"profits-by-denom ","[denom]"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries ProtoRev profits by denom")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"all-profits"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all ProtoRev profits")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"statistics-by-route ","[route]"," where route is the list of pool ids i.e. ","[1,2,3]"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries ProtoRev statistics by route")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"all-statistics"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all ProtoRev statistics")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"hot-routes"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev token pair arb routes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"admin-account"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev admin account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"developer-account"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev developer account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"max-pool-points-per-tx"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev max pool points per transaction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"max-pool-points-per-block"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev max pool points per block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"base-denoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev base denoms used to create cyclic arbitrage routes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"enabled"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries whether the ProtoRev module is currently enabled")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"pool-weights"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the pool weights used to determine how computationally expensive a route is")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"query protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"pool"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the pool id for a given denom pair stored in ProtoRev")))),(0,n.kt)("h3",{id:"proposals"},"Proposals"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Command"),(0,n.kt)("th",{parentName:"tr",align:null},"Subcommand"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-pool-weights ","[path/to/file.json]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the pool weights for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-hot-routes ","[path/to/file.json]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the hot routes for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-base-denoms ","[path/to/file.json]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the base denoms for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-max-pool-points-per-block ","[uint64]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the max pool points per block for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-max-pool-points-per-tx ","[uint64]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the max pool points per transaction for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-developer-account ","[sdk.AccAddress]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a tx to set the developer account for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-admin-account-proposal ","[sdk.AccAddress]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a proposal to set the admin account for ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"tx protorev"),(0,n.kt)("td",{parentName:"tr",align:null},"set-enabled-proposal ","[boolean]"),(0,n.kt)("td",{parentName:"tr",align:null},"Submit a proposal to disable/enable the ProtoRev module")))),(0,n.kt)("h2",{id:"grpc--rest"},"gRPC & REST"),(0,n.kt)("h3",{id:"queries-1"},"Queries"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Verb"),(0,n.kt)("th",{parentName:"tr",align:null},"Method"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/Params"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the parameters of the module")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevNumberOfTrades"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of arbitrage trades the module has executed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevProfitsByDenom"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the profits of the module by denom")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevAllProfits"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of the profits from the module")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevStatisticsByRoute"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of arbitrages and profits that have been executed for a given route")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevAllStatistics"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of routes that the module has arbitrage against and the number of trades and profits that have been executed for each route")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevTokenPairArbRoutes"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of the hot routes that the module is currently arbitraging")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevMaxPoolPointsPerTx"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev max pool points per transaction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevMaxPoolPointsPerBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev max pool points per block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevAdminAccount"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the admin account of the ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevDeveloperAccount"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the developer account of the ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevBaseDenoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the ProtoRev base denoms used to create cyclic arbitrage routes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevEnabled"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries whether the ProtoRev module is currently enabled")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevPoolWeights"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of pool points each pool type will consume when executing and simulating trades")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Query/GetProtoRevPool"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the pool id for a given denom pair stored in ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/params"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the parameters of the module")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/number_of_trades"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of arbitrage trades the module has executed")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/profits_by_denom"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the profits of the module by denom")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/all_profits"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of the profits from the module")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/statistics_by_route"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of arbitrages and profits that have happened for a given route")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/all_route_statistics"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of routes that the module has arbitrage against and the number of trades and profits that have happened for each route")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/token_pair_arb_routes"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries all of the hot routes that the module is currently arbitraging")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/max_pool_points_per_tx"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the maximum number of pool points that can be consumed per transaction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/max_pool_points_per_block"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the maximum number of pool points that can be consumed per block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/admin_account"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the admin account of the ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/developer_account"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the developer account of the ProtoRev")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/base_denoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the base denominations ProtoRev is currently using to create cyclic arbitrage routes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/enabled"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries whether the ProtoRev module is currently enabled")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/pool_weights"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the number of pool points each pool type will consume when executing and simulating trades")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"GET"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/pool"),(0,n.kt)("td",{parentName:"tr",align:null},"Queries the pool id for a given denom pair stored in ProtoRev")))),(0,n.kt)("h3",{id:"transactions-1"},"Transactions"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Verb"),(0,n.kt)("th",{parentName:"tr",align:null},"Method"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetHotRoutes"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the hot routes that will be explored when creating cyclic arbitrage routes. Can only be called by the admin account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetDeveloperAccount"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the account that can withdraw a portion of the profit from the ProtoRev module. Can only be called by the admin account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetMaxPoolPointsPerTx"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the maximum number of pool points that can be consumed per transaction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetMaxPoolPointsPerBlock"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the maximum number of routes that can be iterated per block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetBaseDenoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the base denominations the ProtoRev module will use to create cyclic arbitrage routes")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"gRPC"),(0,n.kt)("td",{parentName:"tr",align:null},"osmosis.protorev.Msg/SetPoolWeights"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the amount of pool points each pool type will consume when executing and simulating trades")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_hot_routes"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the hot routes that will be explored when creating cyclic arbitrage routes. Can only be called by the admin account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_developer_account"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the account that can withdraw a portion of the profit from the ProtoRev module. Can only be called by the admin account")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_max_pool_points_per_tx"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the maximum number of pool points that can be consumed per transaction")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_max_pool_points_per_block"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the maximum number of pool points that can be consumed per block")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_pool_weights"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the amount of pool points each pool type will consume when executing and simulating trades")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"POST"),(0,n.kt)("td",{parentName:"tr",align:null},"/osmosis/protorev/set_base_denoms"),(0,n.kt)("td",{parentName:"tr",align:null},"Sets the base denominations that will be used by ProtoRev to construct cyclic arbitrage routes")))),(0,n.kt)("h2",{id:"events"},"Events"),(0,n.kt)("p",null,"There is 1 type of event that exists in ProtoRev:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.TypeEvtBackrun"),' - "protorev_backrun"')),(0,n.kt)("h3",{id:"typestypeevtbackrun"},(0,n.kt)("inlineCode",{parentName:"h3"},"types.TypeEvtBackrun")),(0,n.kt)("p",null,"This event is emitted after ProtoRev successfully backruns a transaction."),(0,n.kt)("p",null,"It consists of the following attributes:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeValueCategory"),' - "ModuleName"',(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},'The value is the module\'s name - "protorev".'))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyUserPoolId"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the pool id that the user swapped on that ProtoRev backran."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyTxHash"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the transaction hash that ProtoRev backran."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyUserDenomIn"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the user denom in for the swap ProtoRev backran."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyUserDenomOut"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the user denom out for the swap ProtoRev backran."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyBlockPoolPointsRemaining"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the remaining block pool points ProtoRev can still use after the backrun."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyTxPoolPointsRemaining"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the remaining tx pool points ProtoRev can still use after the backrun."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyProtorevProfit"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the profit ProtoRev captured through the backrun."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyProtorevAmountIn"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the amount Protorev swapped in to execute the backrun."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyProtorevAmountOut"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the amount Protorev got out of the backrun swap."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"types.AttributeKeyProtorevArbDenom"),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The value is the denom that ProtoRev swapped in/out to execute the backrun.")))))}d.isMDXComponent=!0}}]);